## JPA = Java Persistence API 
: 자바에서 클래스와 테이블을 자동으로 매핑 시키는 ORM 기술 표준으로 사용되는 인터페이스의 모음을 의미

-	자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 것으로 그림처럼 어플리케이션과 JDBC 사이에서 동작
<br/>

## Jdbc 
: 자바를 통해 데이터 베이스에 접근할 수 있도록 하는 api

-	모든 영구성 프레임워크에는 내부적으로 jdbc API를 사용
-	JDBC는 쿼리 실행 전과 후 뿐만 아니라 로직에서 예외 처리 코드를 넣어 데이터베이스와 연결에서 안정적으로 동작할 수 있게 해야 함
-	또한, 여러 단계의 작업을 하나로 트랜잭션의 처리가 필요하며 그와 관련된 모든 코드를 반복하기 때문에 비효율적임
<br/>

## JPA 사용 이유
-	이러한 JDBC api를 위한 반복적인 코드를 jpa가 대신 처리하여 유지보수가 편리하며,
-	상속, 연관관계 등 데이터베이스와 JAVA 객체 사이 패러다임의 불일치를 해결할 수 있음.
-	데이터베이스 기술에 종속되지 않도록 데이터 접근 추상화를 사용할 수 있기 때문
-	또한, 지연 로딩을 통해서 연관된 객체까지 join으로 가져오는 것이 아니라 실제 사용되는 부분만 가져오고, 필요시 연관된 부분을 조회하게 되는 방식을 이용하여 초기 로딩 시간과 메모리 소비량이 적음
<br/>

## 영속성 
: 데이터를 생성한 프로그램이 종료되어도 사라지지 않고 존재하는 데이터의 특성을 말함

-	영속성을 가지지 않으면, 단지 메모리에 존재하므로 파일 시스템, 데이터베이스 등에 데이터를 영구적으로 저장하려고 함
-	이러한 영속성을 가진 프레임워크는 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있고 안정적인 구동을 보장
<br/>

<hr/>

## JPA가 제공하는 기능 중 영속성으로 관리되는 것은 2가지
-	엔티티와 테이블 매핑 설계 vs 매핑한 엔티티 실제 사용 -> 아래 설명

## 하이버네이트를 이용한 구현 과정
- 엔티티매니저팩토리와 엔티티매니저가 있음
-	엔티니 매니저 팩토리는 이름 그대로 엔티티 매니저를 생성하는 역할을 맡음
-	엔티티 매니저는 엔티티의 저장/수정/삭제/조회 등 엔티티와 관련된 모든 일을 처리함. 관련된 정보를 작성한 파일을 기반으로 엔티티매니저펙토리 생성한 후 엔티티매니저펙토리 라는 공장에서 엔티티매니저를 생성해서 이용함
-	해당 파일에는  DB에 해당하는 드라이버와 url, 유저, 패스워드 등 내용 구성
-	엔티티 매니저 팩토리를 생성하기 위한 비용은 크기 때문에 1개를 만들고 어플리케이션 전체가 공유하는 방식을 이용함

- JPA에서 중요한 용어로 영속성 컨텍스트가 있으며, 엔티티 매니저를 통해 엔티티를 관리하는 환경을 의미함. 
- 영속성 컨텍스트에서는 테이블의 기본 키와 매핑한 식별자 값을 기준으로 엔티티를 구분하기에 영속 상태는 식별자 값이 있어야함.
<br/>

## 영속성 컨텍스트 이용 장점
- 1차 캐시, 트랙잭션 지원하는 쓰기 지연, 변경감지
1. 영속성컨텍스트는 내부에 캐시를 가져 영속 상태 엔티티 이 1차 캐시에 저장함 -> 엔티티매니저의 find를 통한 조회는 우선 1차 캐시에 진행하게 되고, 없으면 DB에서 조회
2. 지연 쓰기가 가능한 이유는 쿼리를 바로 db에 전달해도 트랜잭션을 커밋하지 않으면 의미가 없고, 커밋 직전에만 db에 쿼리를 전달하면 되는 방식을 취하고 있기 때문
3. 엔티티의 수정시, 추가로 update 같은 엔티티매니저를 이용하지 않고 조회한 엔티티의 데이터 변경만으로 db에 자동으로 반영하는 것을 변경 감지라고 함. 그리고 이러한 변경 감지는 영속상태의 엔티티만 적용이 됨. JPA 기본 전략은 엔티티 변경시에 모두 필드를 업데이트하는 것으로, 데이터 전송량은 증가하지만 바인딩되는 데이터외 수정 쿼리 형태는 같아서 애플리케이션 로딩 시정에 미리 생성한 쿼리를 재사용할 수 있음. 그리고 동일한 쿼리는 db에서 이전에 파싱된 쿼리를 재사용할 수 있음.
<br/>

<hr/>

## 엔티티 생명주기
- 엔티티는 4가지 상태 : 비영속, 영속, 준영속, 삭제

1. 비영속 : 어플리케이션 내부에서는 객체가 생성되었지만 아직 영속성 컨텍스트에 저장되지 않은 상태
2. 영속 : 엔티티 매니저를 통해 영속성 컨텍스트에 저장해서 관리되는 상태로 persist 또는 find 메소드를 통해 상태가 영속으로 변경이 됨
3. 준영속 : 영속 상태 엔티티가 영속성 컨텍스트와 분리되어 관리되지x 상태
4. 삭제 : remove에 의해 영속성컨텍스트와 DB에 해당 엔티티가 없는 상태
<br/>

<hr/>

## flush
: jpa에서는 트랜잭션을 커밋할 때, 영속성컨텍스트의 새로 저장되는 엔티티를 db에 반영하는 것

- 엔티티매니저의 flush 메소드 또는 트랜잭션 커밋시에 자동으로 호출됨

Commit시 동작을 보면 먼저 flush가 되야 함 
1. 엔티티와 1차 캐시에 저장되는 시점에 엔티티 상태를 보관하는 스냅샷과 비교를 진행하며 변경된 엔티티를 찾게 됨. 
2. 변경된 엔티티가 있으면, 변경 감지된 내용에 따라 수정 쿼리를 생성하여 쓰기 지연 sql 저장소에 보냄.
3. 쓰기 지연 sql 저장소의 sql을 DB로 보내는 것으로 flush를 종료함
4. 마지막으로 데이터베이스 트랜잭션을 커밋함
- 1차 캐시에 저장될 때, 저장되는 시점의 상태를 스냅샷으로 만들어 1차 캐시에 보관하며, 스냅샷과 영속성컨텍스트의 모든 엔티티를 비교해서 수정된 엔티티를 위한 수정쿼리를 sql저장소에 등록함. 그리고 sql 저장소의 쿼리를 db에 전송하는 과정이 발생함.

## flush vs flush()
flush는 트랜잭션을 커밋하는 순간에 영속성 컨텍스트에 새로 저장된 엔티티를 DB에 반영하는 것을 의미함
flush()는 엔티티와 스냅샷 비교, 쓰기 지연 SQL 저장소에 등록, 저장소의 쿼리를 DB로 전송이 합쳐진 것으로 실제 반영을 위해서 commit()의 트랙잭션 commit이 동작해야함
<br/>
